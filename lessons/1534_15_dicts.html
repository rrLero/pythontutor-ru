{% section "Словари" %}
<p>Обычные списки (массивы) представляют собой набор пронумерованных элементов,
то есть для обращения к какому-либо элементу списка необходимо указать его номер.
Номер элемента в списке однозначно идентифицирует сам элемент. Но идентифицировать
данные по числовым номерам не всегда оказывается удобно. Например, маршруты поездов
в России идентифицируются численно-буквенным кодом (число и одна цифра), также численно-буквенным
кодом идентифицируются авиарейсы, то есть для хранения информации о рейсах поездов или
самолетов в качестве идентификатора удобно было бы использовать не число, а текстовую строку.

<p>Структура данных, позволяющая идентифицировать ее элементы не по числовому индексу,
а по произвольному, называется <i>словарем</i> или <i>ассоциативным массивом</i>.
Соответствующая структура данных в языке Питон называется <code>dict</code>.

<p>Рассмотрим простой пример использования словаря. Заведем словарь <code>Capitals</code>,
где индексом является название страны, а значением&nbsp;&mdash; название столицы этой страны.
Это позволит легко определять по строке с названием страны ее столицу.

{% program %}
# Создадим пустой словать Capitals
Capitals = dict()

# Заполним его несколькими значениями
Capitals['Russia'] = 'Moscow'
Capitals['Ukraine'] = 'Kiev'
Capitals['USA'] = 'Washington'

Countries = ['Russia', 'France', 'USA', 'Russia']

for country in Countries:
    # Для каждой страны из списка проверим, есть ли она в словаре Capitals
    if country in Capitals:
        print('Столица страны ' + country + ': ' + Capitals[country])
    else:
        print('В базе нет страны c названием ' + country)

{% endprogram %}

<p>Итак, каждый элемент словаря состоит из двух объектов:
<i>ключа</i> и <i>значения</i>. В нашем примере ключом
является название страны, значением является название столицы.
Ключ идентифицирует элемент словаря, значение является данными,
которые соответствуют данному ключу. Значения ключей&nbsp;&mdash;
уникальны, двух одинаковых ключей в словаре быть не может.

<p>В жизни широко распространены словари, например, привычные бумажные
словари (толковые, орфографические, лингвистические). В них ключом
является слово-заголовок статьи, а значением&nbsp;&mdash; сама статья.
Для того, чтобы получить доступ к статье, необходимо указать слово-ключ.

<p>Другой пример словаря, как структуры данных&nbsp;&mdash; телефонный справочник.
В нем ключом является имя, а значением&nbsp;&mdash; номер телефона. И словарь, и телефонный
справочник хранятся так, что легко найти элемент словаря по известному ключу (например,
если записи хранятся в алфавитном порядке ключей, то легко можно найти известный ключ,
например, бинарным поиском), но если ключ неизвествен, а известно лишь значение, то
поиск элемента с данным значением может потребовать последовательного просмотра всех элементов
словаря.</p>

<p>Особенностью ассоциативного массива является его динамичность:
в него можно добавлять новые элементы с произвольными ключами и удалять уже существующие элементы.
При этом размер используемой памяти пропорционален размеру ассоциативного массива.
Доступ к элементам ассоциативного массива выполняется хоть и медленнее, чем
к обычным массивам, но в целом довольно быстро.

<p>В языке Питон как ключом может быть произвольный неизменяемый тип данных:
целые и действительные числа, строки, кортежи. Ключом в словаре не может
быть множество, но может быть элемент типа <code>frozenset</code>: специальный
тип данных, являющийся аналогом типа <code>set</code>, который нельзя изменять после создания.
Значением элемента словаря может быть любой тип данных, в том числе и изменяемый.

<h2>Когда нужно использовать словари</h2>

<p>Словари нужно использовать в следующих случаях:

<ul>
    <li>Подсчет числа каких-то объектов. В этом случае нужно завести словарь,
    в котором ключами являются объекты, а значениями&nbsp;&mdash; их количество.
    <li>Хранение каких-либо данных, связанных с объектом. Ключи&nbsp;&mdash;
    объекты, значения&nbsp;&mdash; связанные с ними данные. Например, если нужно
    по названию месяца определить его порядковый номер, то это можно сделать
    при помощи словаря <code>Num['January'] = 1; Num['February'] = 2; ...</code>.
    <li>Установка соответствия между объектами (например, &ldquo;родитель&mdash;потомок&rdquo;).
    Ключ&nbsp;&mdash; объект, значение&nbsp;&mdash; соответствующий ему объект.
    <li>Если нужен обычный массив, но при этом масимальное значение индекса элемента очень велико,
    но при этом будут использоваться не все возможные индексы (так называемый
    &ldquo;разреженный массив&rdquo;), то можно использовать ассоциативный
    массив для экономии памяти.
</ul>

<h2>Создание словаря</h2>

<p>Пустой словарь можно создать при помощи функции <code>dict()</code> или 
пустой пары фигурных скобок <code>{}</code> (вот почему фигурные скобки
нельзя использовать для создания пустого множества). Для создания словаря
с некоторым набором начальных значений можно использовать следующие конструкции:

{% program %}
Capitals = {'Russia': 'Moscow', 'Ukraine': 'Kiev', 'USA': 'Washington'}
Capitals = dict(Russia = 'Moscow', Ukraine = 'Kiev', USA = 'Washington')
Capitals = dict([("Russia", "Moscow"), ("Ukraine", "Kiev"), ("USA", "Washington")])
Capitals = dict(zip(["Russia", "Ukraine", "USA"], ["Moscow", "Kiev", "Washington"]))
print(Capitals)
{% endprogram %}

<p>Первые два способа можно использовать только для создания небольших словарей, перечисляя все их элементы.
Кроме того, во втором способе ключи передаются как именованные параметры функции <code>dict</code>, поэтому
в этом случае ключи могут быть только строками, причем являющимися корректными идентификаторами.
В третьем и четвертом случае можно создавать большие словари, если в качестве аргументов
передавать уже готовые списки, которые могут быть получены не обязательно перечислением всех элементов,
а любым другим способом построены по ходу исполнения программы. В третьем способе
функции <code>dict</code> нужно передать список, каждый элемент которого является кортежем
из двух элементов: ключа и значения. В четвертом способе используется функция <code>zip</code>,
которой передается два списка одинаковой длины: список ключей и список значений.

<h2>Работа с элементами словаря</h2>

<p>Основная операция: получение значения элемента по ключу, записывается так же, как и для 
списков: <code>A[key]</code>. Если элемента с заданным ключом не существует в словаре,
то возникает исключение <code>KeyError</code>.

<p>Другой способ определения значения по ключу&nbsp;&mdash; метод <code>get</code>:
<code>A.get(key)</code>. Если элемента с ключом <code>get</code> нет в словаре,
то возвращается значение <code>None</code>. В форме записи с двумя аргументами
<code>A.get(key, val)</code> метод возвращает значение <code>val</code>, 
если элемент с ключом <code>key</code> отсутствует в словаре.

<p>Проверить принадлежность элемента словарю можно операциями <code>in</code>
и <code>not in</code>, как и для множеств.

<p>Для добавления нового элемента в словарь нужно просто присвоить ему какое-то значение:
<code>A[key] = value</code>.

<p>Для удаления элемента из словаря можно использовать операцию <code>del A[key]</code>
(операция возбуждает исключение <code>KeyError</code>, если такого ключа в словаре нет.
Вот два безопасных способа удаления элемента из словаря.

{% program %}
A = {'ab' : 'ba', 'aa' : 'aa', 'bb' : 'bb', 'ba' : 'ab'}

key = 'ac'
if key in A:
    del A[key]

try:
    del A[key]
except KeyError:
	print('There is no element with key "' + key + '" in dict')
print(A)
{% endprogram %}

<p>В первом случае мы предварительно проверяем наличие элемента, а во втором - перехватываем и обрабатываем исключение.

<p>Еще один способ удалить элемент из словаря: использование метода <code>pop</code>:
<code>A.pop(key)</code>. Этот метод возвращает значение удаляемого элемента, если
элемент с данным ключом отсутствует в словаре, то возбуждается исключение. Если
методу <code>pop</code> передать второй параметр, то если элемент в словаре отсутствует,
то метод <code>pop</code> возвратит значение этого параметра. Это позволяет
проще всего организовать безопасное удаление элемента из словаря: <code>A.pop(key, None)</code>.



<h2>Перебор элементов словаря</h2>

<p>Можно легко организовать перебор ключей всех элементов в словаре:

{% program %}
A = dict(zip('abcdef', list(range(6))))
for key in A:
    print(key, A[key])
{% endprogram %}

<p>Следующие методы возвращают <i>представления</i> элементов словаря.
Представления во многом похожи на множества, но они изменяются,
если менять значения элементов словаря. Метод <code>keys</code>
возвращает представление ключей всех элементов, метод <code>values</code>
возвращает представление всех значений, а метод <code>items</code>
возвращает представление всех пар (кортежей) из ключей и значений.

<p>Соответственно, быстро проверить, если ли значение <code>val</code>
среди всех значений элементов словаря <code>A</code> можно так:
<code>val in A.values()</code>, а организовать цикл так, чтобы
в переменной <code>key</code> был ключ элемента, а в переменной <code>val</code>
было его значение можно так:
{% program %}
A = dict(zip('abcdef', list(range(6))))
for key, val in A.items():
    print(key, val)
{% endprogram %}
{% endsection %}
